#!/usr/bin/env node

/**
 * Renkei System - Start Script
 * tmux„Çª„ÉÉ„Ç∑„Éß„É≥Ëµ∑Âãï„Éª„Ç∑„Çπ„ÉÜ„É†ÈñãÂßã
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// „Ç´„É©„ÉºÂá∫ÂäõÁî®„ÅÆÂÆöÊï∞
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

// „É≠„Ç∞Âá∫ÂäõÈñ¢Êï∞
function log(message, color = colors.white) {
  console.log(`${color}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`‚úÖ ${message}`, colors.green);
}

function logError(message) {
  log(`‚ùå ${message}`, colors.red);
}

function logWarning(message) {
  log(`‚ö†Ô∏è  ${message}`, colors.yellow);
}

function logInfo(message) {
  log(`‚ÑπÔ∏è  ${message}`, colors.blue);
}

function logHeader(message) {
  log(`\n${colors.bold}üöÄ ${message}${colors.reset}`, colors.cyan);
}

// Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÔºà„Éó„É≠„Éï„Ç°„Ç§„É´ÂØæÂøúÔºâ
function loadConfig(profileName = null) {
  let config;
  
  try {
    // „Éó„É≠„Éï„Ç°„Ç§„É´ÊåáÂÆöÊôÇ„ÅÆÂá¶ÁêÜ
    if (profileName) {
      const profilePath = path.join(process.cwd(), 'config', 'profiles', `${profileName}.json`);
      if (fs.existsSync(profilePath)) {
        config = JSON.parse(fs.readFileSync(profilePath, 'utf8'));
        logInfo(`Loaded profile configuration: ${profileName}`);
        logInfo(`Profile path: ${profilePath}`);
      } else {
        throw new Error(`Profile '${profileName}' not found at: ${profilePath}`);
      }
    } else {
      // ÈÄöÂ∏∏„ÅÆË®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
      const userSettingsPath = path.join(process.cwd(), 'data/user-settings.json');
      const defaultSettingsPath = path.join(process.cwd(), 'config/default-settings.json');
      
      if (fs.existsSync(userSettingsPath)) {
        config = JSON.parse(fs.readFileSync(userSettingsPath, 'utf8'));
        logInfo(`Loaded user settings from: ${userSettingsPath}`);
      } else if (fs.existsSync(defaultSettingsPath)) {
        config = JSON.parse(fs.readFileSync(defaultSettingsPath, 'utf8'));
        logInfo(`Loaded default settings from: ${defaultSettingsPath}`);
      } else {
        throw new Error('No configuration file found. Please run "scripts/renkei-setup" first.');
      }
    }
    
    // „Éó„É≠„Éï„Ç°„Ç§„É´ÊÉÖÂ†±„ÇíË®≠ÂÆö„Å´ËøΩÂä†
    if (profileName) {
      config.currentProfile = profileName;
    }
    
    return config;
  } catch (error) {
    logError(`Failed to load configuration: ${error.message}`);
    throw error;
  }
}

// Âà©Áî®ÂèØËÉΩ„Å™„Éó„É≠„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
function listAvailableProfiles() {
  const profilesDir = path.join(process.cwd(), 'config', 'profiles');
  const profiles = [];
  
  try {
    if (fs.existsSync(profilesDir)) {
      const files = fs.readdirSync(profilesDir);
      files.forEach(file => {
        if (file.endsWith('.json')) {
          const profileName = file.replace('.json', '');
          profiles.push(profileName);
        }
      });
    }
    
    return profiles;
  } catch (error) {
    logWarning(`Failed to list profiles: ${error.message}`);
    return [];
  }
}

// tmux„Çª„ÉÉ„Ç∑„Éß„É≥Â≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ
function checkTmuxSession(sessionName) {
  try {
    execSync(`tmux has-session -t ${sessionName}`, { stdio: 'pipe' });
    return true;
  } catch (error) {
    return false;
  }
}

// tmux„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê
function createTmuxSession(config) {
  const sessionName = config.tmux.sessionName;
  
  if (checkTmuxSession(sessionName)) {
    logWarning(`tmux session '${sessionName}' already exists`);
    logInfo('Attaching to existing session...');
    
    try {
      // Êó¢Â≠ò„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆ„Éö„Ç§„É≥ÊÉÖÂ†±„ÇíÂèñÂæó
      const panes = execSync(`tmux list-panes -t ${sessionName} -F "#{pane_id}"`, { encoding: 'utf8' })
        .trim()
        .split('\n');
      
      return {
        sessionName,
        mainPaneId: panes[0] || `${sessionName}:0.0`,
        subPaneId: panes[1] || null,
        chatPaneId: panes[2] || null,
        isExisting: true
      };
    } catch (error) {
      logError(`Failed to get existing session info: ${error.message}`);
      throw error;
    }
  }
  
  try {
    // Êñ∞„Åó„ÅÑtmux„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê
    logInfo(`Creating tmux session: ${sessionName}`);
    
    // „Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê„Ç≥„Éû„É≥„ÉâÊßãÁØâ
    const tmuxCommand = [
      'tmux',
      'new-session',
      '-d',
      '-s', sessionName,
      '-x', '120',
      '-y', '40',
      '-c', process.cwd()
    ];
    
    execSync(tmuxCommand.join(' '), { stdio: 'pipe' });
    logSuccess(`Created tmux session: ${sessionName}`);
    
    // TypeScript„Éì„É´„Éâ„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const layoutPath = path.join(process.cwd(), 'dist', 'ui', 'layouts', 'three-pane-layout.js');
    if (!fs.existsSync(layoutPath)) {
      logWarning('ThreePaneLayout not found. Falling back to manual 3-pane layout creation.');
      
      // ÊâãÂãï„Åß3„Éö„Ç§„É≥„É¨„Ç§„Ç¢„Ç¶„Éà„Çí‰ΩúÊàê
      // „É°„Ç§„É≥„Éö„Ç§„É≥„ÅÆ„Çø„Ç§„Éà„É´Ë®≠ÂÆö
      execSync(`tmux select-pane -t ${sessionName}:0.0 -T "${config.tmux.mainPaneTitle}"`, { stdio: 'pipe' });
      
      // ‰∏ãÈÉ®Áî®„ÅÆ„Éö„Ç§„É≥„Çí‰ΩúÊàêÔºàÂõ∫ÂÆö„Çµ„Ç§„Ç∫20Ë°åÔºâ
      const bottomPaneId = execSync(`tmux split-window -t ${sessionName}:0 -v -l 20 -P -F "#{pane_id}"`, { encoding: 'utf8' }).trim();
      
      // ‰∏ãÈÉ®„Éö„Ç§„É≥„ÇíÂ∑¶Âè≥„Å´ÂàÜÂâ≤Ôºà„Çπ„ÉÜ„Éº„Çø„ÇπÁî®„Å´60ÂàóÔºâ
      const statusPaneId = execSync(`tmux split-window -t ${bottomPaneId} -h -l 60 -P -F "#{pane_id}"`, { encoding: 'utf8' }).trim();
      const chatPaneId = bottomPaneId;
      
      // „Éö„Ç§„É≥„Çø„Ç§„Éà„É´Ë®≠ÂÆö
      execSync(`tmux select-pane -t ${chatPaneId} -T "${config.tmux.chatPaneTitle || 'üí¨ Interactive Chat'}"`, { stdio: 'pipe' });
      execSync(`tmux select-pane -t ${statusPaneId} -T "${config.tmux.subPaneTitle}"`, { stdio: 'pipe' });
      
      // „Éö„Ç§„É≥„Éú„Éº„ÉÄ„ÉºË°®Á§∫„ÇíÊúâÂäπÂåñ
      execSync(`tmux set-option -t ${sessionName} pane-border-status top`, { stdio: 'pipe' });
      
      // „É°„Ç§„É≥„Éö„Ç§„É≥„Å´„Éï„Ç©„Éº„Ç´„Çπ
      execSync(`tmux select-pane -t ${sessionName}:0.0`, { stdio: 'pipe' });
      
      // „É°„Ç§„É≥„Éö„Ç§„É≥ID„ÇíÂèñÂæó
      const mainPaneId = execSync(`tmux list-panes -t ${sessionName} -F "#{pane_id}" | head -n 1`, { encoding: 'utf8' }).trim();
      
      logSuccess('3-pane tmux layout created manually');
      
      const result = {
        sessionName,
        mainPaneId,
        subPaneId: statusPaneId,
        chatPaneId,
        isExisting: false
      };
      
      logInfo(`Session info - Main: ${result.mainPaneId}, Status: ${result.subPaneId}, Chat: ${result.chatPaneId}`);
      return result;
    } else {
      // ThreePaneLayout„Çí‰ΩøÁî®
      const { ThreePaneLayout } = require('../dist/ui/layouts/three-pane-layout');
      
      const layoutManager = new ThreePaneLayout({
        sessionName,
        mainPaneTitle: config.tmux.mainPaneTitle,
        chatPaneTitle: config.tmux.chatPaneTitle || 'üí¨ Interactive Chat',
        statusPaneTitle: config.tmux.subPaneTitle || 'üìä Worker Status',
        mainPaneHeightPercent: config.tmux.mainPaneSize || 50,
        chatPaneWidthPercent: config.tmux.chatPaneSize || 50
      });
      
      const layoutResult = layoutManager.createLayout();
      
      // „Éö„Ç§„É≥„Éú„Éº„ÉÄ„ÉºË°®Á§∫„ÇíÊúâÂäπÂåñ
      execSync(`tmux set-option -t ${sessionName} pane-border-status top`, { stdio: 'pipe' });
      
      logSuccess('3-pane tmux layout created with ThreePaneLayout');
      
      const result = {
        sessionName,
        mainPaneId: layoutResult.mainPaneId,
        subPaneId: layoutResult.statusPaneId,
        chatPaneId: layoutResult.chatPaneId,
        isExisting: false
      };
      
      logInfo(`Session info - Main: ${result.mainPaneId}, Status: ${result.subPaneId}, Chat: ${result.chatPaneId}`);
      return result;
    }
    
  } catch (error) {
    logError(`Failed to create tmux session: ${error.message}`);
    throw error;
  }
}

// TypeScript„Éì„É´„Éâ
function buildTypeScript() {
  try {
    logInfo('Building TypeScript...');
    
    // TypeScriptË®≠ÂÆö„Éï„Ç°„Ç§„É´Á¢∫Ë™ç
    const tsconfigPath = path.join(process.cwd(), 'tsconfig.json');
    if (!fs.existsSync(tsconfigPath)) {
      logWarning('tsconfig.json not found. Skipping TypeScript build.');
      return;
    }
    
    // „Éì„É´„ÉâÂÆüË°å
    execSync('npm run build', { stdio: 'inherit' });
    logSuccess('TypeScript build completed');
    
  } catch (error) {
    logError(`TypeScript build failed: ${error.message}`);
    throw error;
  }
}

// „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï
function startSystem(config, sessionInfo) {
  try {
    logInfo('Starting Renkei System...');
    
    const { mainPaneId, subPaneId, chatPaneId } = sessionInfo;
    
    // „É°„Ç§„É≥„Éö„Ç§„É≥„Åß„Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï
    const startCommand = `node dist/index.js`;
    execSync(`tmux send-keys -t ${mainPaneId} "${startCommand}" Enter`, { stdio: 'pipe' });
    
    // „Çµ„Éñ„Éö„Ç§„É≥„ÅßÁõ£Ë¶ñË°®Á§∫Ôºà„Çµ„Éñ„Éö„Ç§„É≥„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥ÂêàÔºâ
    if (subPaneId) {
      const monitorCommand = `echo "Renkei System Output Monitor" && echo "System started at $(date)"`;
      execSync(`tmux send-keys -t ${subPaneId} "${monitorCommand}" Enter`, { stdio: 'pipe' });
    } else {
      logWarning('Sub-pane not found. Monitor display skipped.');
    }
    
    // „ÉÅ„É£„ÉÉ„Éà„Éö„Ç§„É≥„ÅÆÂàùÊúüÂåñÔºà„ÉÅ„É£„ÉÉ„Éà„Éö„Ç§„É≥„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥ÂêàÔºâ
    if (chatPaneId) {
      logInfo(`Initializing chat pane: ${chatPaneId}`);
      const chatCommand = `echo "üí¨ Interactive Chat Interface" && echo "Initializing chat system..." && echo "Type 'help' for available commands" && echo "Chat pane is ready for future implementation"`;
      execSync(`tmux send-keys -t ${chatPaneId} "${chatCommand}" Enter`, { stdio: 'pipe' });
      logSuccess('Chat interface initialized');
    }
    
    logSuccess('System startup commands sent to tmux session');
    
  } catch (error) {
    logError(`Failed to start system: ${error.message}`);
    throw error;
  }
}

// ÂàùÊúüÁîªÈù¢Ë°®Á§∫„Å®„É≠„Ç∞Áõ£Ë¶ñÈñãÂßã
function displayWelcomeScreen(config, sessionInfo) {
  try {
    const { sessionName, subPaneId } = sessionInfo;
    
    // „É≠„Ç∞„Éï„Ç°„Ç§„É´„ÅÆÂ≠òÂú®Á¢∫Ë™ç„Éª‰ΩúÊàê
    const logDir = path.join(process.cwd(), 'data', 'logs');
    const logFile = path.join(logDir, 'renkei-worker.log');
    
    // „É≠„Ç∞„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
      logInfo('Created logs directory');
    }
    
    // „É≠„Ç∞„Éï„Ç°„Ç§„É´ÂàùÊúüÂåñ
    if (!fs.existsSync(logFile)) {
      const initialMessage = `[${new Date().toISOString()}] üöÄ Renkei System initialized\n`;
      fs.writeFileSync(logFile, initialMessage);
      logInfo('Created worker log file');
    }
    
    // „Çµ„Éñ„Éö„Ç§„É≥„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÂá¶ÁêÜ
    if (!subPaneId) {
      logWarning('Sub-pane not found. Welcome screen display skipped.');
      return;
    }
    
    // ÂàùÊúü„Éò„ÉÉ„ÉÄ„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Çµ„Éñ„Éö„Ç§„É≥„Å´ÈÄÅ‰ø°
    const headerMessages = [
      '',
      '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
      'ü§ñ Renkei System - Worker Status Monitor',
      '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ',
      ''
    ];
    
    headerMessages.forEach(message => {
      execSync(`tmux send-keys -t ${subPaneId} "echo '${message}'" Enter`, { stdio: 'pipe' });
    });
    
    // „É≠„Ç∞Áõ£Ë¶ñ„Ç≥„Éû„É≥„Éâ„ÇíÈñãÂßã - „Çà„ÇäÁ∞°Âçò„ÅßÁ¢∫ÂÆü„Å™ÊñπÊ≥ï
    const logMonitorCommand = `tail -f "${logFile}" || echo "Waiting for worker logs..."`;
    execSync(`tmux send-keys -t ${subPaneId} "${logMonitorCommand}" Enter`, { stdio: 'pipe' });
    
    logSuccess('Worker status monitor started');
    logInfo(`Monitoring log file: ${logFile}`);
    
  } catch (error) {
    logWarning(`Failed to start worker monitor: ${error.message}`);
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÈùôÁöÑ„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
    try {
      if (sessionInfo.subPaneId) {
        execSync(`tmux send-keys -t ${sessionInfo.subPaneId} "echo 'Worker status monitor unavailable. Check logs manually.'" Enter`, { stdio: 'pipe' });
      }
    } catch (fallbackError) {
      logError(`Fallback display also failed: ${fallbackError.message}`);
    }
  }
}

// „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã‰øùÂ≠ò
function saveSessionState(config) {
  try {
    const sessionDir = config.sessionDir || path.join(process.cwd(), 'data/sessions');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sessionStateFile = path.join(sessionDir, `session-${timestamp}.json`);
    
    const sessionState = {
      timestamp: new Date().toISOString(),
      sessionName: config.tmux.sessionName,
      workspaceDir: config.workspaceDir,
      pid: process.pid,
      platform: os.platform(),
      nodeVersion: process.version
    };
    
    // „Éá„Ç£„É¨„ÇØ„Éà„É™Á¢∫Ë™ç„Éª‰ΩúÊàê
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true });
    }
    
    fs.writeFileSync(sessionStateFile, JSON.stringify(sessionState, null, 2));
    logInfo(`Session state saved: ${sessionStateFile}`);
    
  } catch (error) {
    logWarning(`Failed to save session state: ${error.message}`);
    // ÈùûËá¥ÂëΩÁöÑ„Ç®„É©„Éº„Å®„Åó„Å¶Á∂ôÁ∂ö
  }
}

// Áí∞Â¢É„ÉÅ„Çß„ÉÉ„ÇØ
function preflightCheck() {
  logHeader('Preflight Check');
  
  let allChecksPass = true;
  
  // Node.js „ÉÅ„Çß„ÉÉ„ÇØ
  try {
    const nodeVersion = process.version;
    logSuccess(`Node.js: ${nodeVersion}`);
  } catch (error) {
    logError('Node.js version check failed');
    allChecksPass = false;
  }
  
  // tmux „ÉÅ„Çß„ÉÉ„ÇØ
  try {
    const tmuxVersion = execSync('tmux -V', { encoding: 'utf8', stdio: 'pipe' });
    logSuccess(`tmux: ${tmuxVersion.trim()}`);
  } catch (error) {
    logError('tmux is not available');
    allChecksPass = false;
  }
  
  // ÂøÖË¶Å„Å™„Éá„Ç£„É¨„ÇØ„Éà„É™„ÉÅ„Çß„ÉÉ„ÇØ
  const requiredDirs = ['data', 'workspace', 'scripts'];
  requiredDirs.forEach(dir => {
    const dirPath = path.join(process.cwd(), dir);
    if (fs.existsSync(dirPath)) {
      logSuccess(`Directory exists: ${dir}`);
    } else {
      logError(`Required directory missing: ${dir}`);
      allChecksPass = false;
    }
  });
  
  // package.json „ÉÅ„Çß„ÉÉ„ÇØ
  const packageJsonPath = path.join(process.cwd(), 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    logSuccess('package.json found');
  } else {
    logError('package.json not found');
    allChecksPass = false;
  }
  
  if (!allChecksPass) {
    logError('Preflight check failed. Please run "scripts/renkei-setup" first.');
    process.exit(1);
  }
  
  logSuccess('Preflight check completed');
}

// „Çª„ÉÉ„Ç∑„Éß„É≥Âæ©ÂÖÉÊ©üËÉΩ
function restoreSession(sessionId) {
  try {
    logHeader('Session Restoration');
    
    const sessionDir = path.join(process.cwd(), 'data', 'sessions');
    let sessionFile;
    
    if (sessionId === 'latest') {
      // ÊúÄÊñ∞„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„ÇíÊé¢„Åô
      const sessionFiles = fs.readdirSync(sessionDir)
        .filter(file => file.startsWith('session-') && file.endsWith('.json'))
        .sort()
        .reverse();
      
      if (sessionFiles.length === 0) {
        throw new Error('No session files found');
      }
      
      sessionFile = path.join(sessionDir, sessionFiles[0]);
      logInfo(`Found latest session: ${sessionFiles[0]}`);
    } else {
      // ÊåáÂÆö„Åï„Çå„Åü„Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÊé¢„Åô
      sessionFile = path.join(sessionDir, `session-${sessionId}.json`);
      if (!fs.existsSync(sessionFile)) {
        // session-„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Åå„Å™„ÅÑÂ†¥Âêà„ÇÇË©¶„Åô
        sessionFile = path.join(sessionDir, `${sessionId}.json`);
        if (!fs.existsSync(sessionFile)) {
          throw new Error(`Session '${sessionId}' not found`);
        }
      }
    }
    
    // „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±Ë™≠„ÅøËæº„Åø
    const sessionState = JSON.parse(fs.readFileSync(sessionFile, 'utf8'));
    logInfo(`Restoring session from: ${sessionFile}`);
    logInfo(`Session timestamp: ${sessionState.timestamp}`);
    logInfo(`Session name: ${sessionState.sessionName}`);
    
    return sessionState;
    
  } catch (error) {
    logError(`Session restoration failed: ${error.message}`);
    throw error;
  }
}

// „Ç∑„Çπ„ÉÜ„É†Ë®∫Êñ≠Ê©üËÉΩ
function runDiagnostics() {
  logHeader('System Diagnostics');
  
  const diagnostics = {
    environment: {},
    performance: {},
    issues: []
  };
  
  try {
    // Áí∞Â¢ÉÊÉÖÂ†±ÂèéÈõÜ
    diagnostics.environment = {
      nodeVersion: process.version,
      platform: os.platform(),
      arch: os.arch(),
      totalMemory: os.totalmem(),
      freeMemory: os.freemem(),
      uptime: os.uptime(),
      loadAverage: os.loadavg()
    };
    
    logInfo(`Platform: ${diagnostics.environment.platform} (${diagnostics.environment.arch})`);
    logInfo(`Node.js: ${diagnostics.environment.nodeVersion}`);
    logInfo(`Memory: ${Math.round(diagnostics.environment.freeMemory / 1024 / 1024)}MB free / ${Math.round(diagnostics.environment.totalMemory / 1024 / 1024)}MB total`);
    
    // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
    const startTime = Date.now();
    
    // tmuxÂøúÁ≠îÊÄß„ÉÜ„Çπ„Éà
    try {
      execSync('tmux list-sessions', { stdio: 'pipe', timeout: 5000 });
      const tmuxResponseTime = Date.now() - startTime;
      diagnostics.performance.tmuxResponse = tmuxResponseTime;
      logSuccess(`tmux response time: ${tmuxResponseTime}ms`);
    } catch (error) {
      diagnostics.issues.push('tmux response test failed');
      logWarning('tmux response test failed');
    }
    
    // „Éá„Ç£„Çπ„ÇØÂÆπÈáè„ÉÅ„Çß„ÉÉ„ÇØ
    try {
      const workspaceDir = path.join(process.cwd());
      const stats = fs.statSync(workspaceDir);
      diagnostics.performance.workspaceAccess = Date.now() - startTime;
      logSuccess(`Workspace access: ${diagnostics.performance.workspaceAccess}ms`);
    } catch (error) {
      diagnostics.issues.push('workspace access test failed');
      logWarning('Workspace access test failed');
    }
    
    // ‰æùÂ≠òÈñ¢‰øÇ„ÉÅ„Çß„ÉÉ„ÇØ
    const requiredCommands = ['node', 'npm', 'tmux'];
    requiredCommands.forEach(cmd => {
      try {
        execSync(`which ${cmd}`, { stdio: 'pipe' });
        logSuccess(`${cmd}: available`);
      } catch (error) {
        diagnostics.issues.push(`${cmd} not found`);
        logError(`${cmd}: not available`);
      }
    });
    
    // „É°„É¢„É™‰ΩøÁî®Áéá„ÉÅ„Çß„ÉÉ„ÇØ
    const memoryUsage = (1 - diagnostics.environment.freeMemory / diagnostics.environment.totalMemory) * 100;
    if (memoryUsage > 90) {
      diagnostics.issues.push('High memory usage detected');
      logWarning(`Memory usage: ${memoryUsage.toFixed(1)}% (high)`);
    } else {
      logSuccess(`Memory usage: ${memoryUsage.toFixed(1)}% (normal)`);
    }
    
    // Ë®∫Êñ≠ÁµêÊûú„Çµ„Éû„É™„Éº
    if (diagnostics.issues.length === 0) {
      logSuccess('All diagnostics passed');
    } else {
      logWarning(`${diagnostics.issues.length} issues detected:`);
      diagnostics.issues.forEach(issue => logWarning(`  - ${issue}`));
    }
    
    return diagnostics;
    
  } catch (error) {
    logError(`Diagnostics failed: ${error.message}`);
    throw error;
  }
}

// „É°„É≥„ÉÜ„Éä„É≥„ÇπÊ©üËÉΩ
function performMaintenance() {
  logHeader('System Maintenance');
  
  try {
    // „É≠„Ç∞„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥
    performLogRotation();
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
    clearSystemCache();
    
    // Ë®≠ÂÆö„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
    backupConfiguration();
    
    logSuccess('System maintenance completed successfully');
    
  } catch (error) {
    logError(`Maintenance failed: ${error.message}`);
    throw error;
  }
}

// „É≠„Ç∞„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥
function performLogRotation() {
  try {
    logInfo('Performing log rotation...');
    
    const logsDir = path.join(process.cwd(), 'data', 'logs');
    const maxLogFiles = 10;
    const maxLogSize = 10 * 1024 * 1024; // 10MB
    
    // „É≠„Ç∞„Éá„Ç£„É¨„ÇØ„Éà„É™Á¢∫Ë™ç„Éª‰ΩúÊàê
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
      logInfo('Created logs directory');
      return;
    }
    
    // „É≠„Ç∞„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
    const logFiles = fs.readdirSync(logsDir)
      .filter(file => file.endsWith('.log'))
      .map(file => {
        const fullPath = path.join(logsDir, file);
        const stats = fs.statSync(fullPath);
        return { name: file, path: fullPath, size: stats.size, mtime: stats.mtime };
      })
      .sort((a, b) => b.mtime - a.mtime);
    
    let rotated = 0;
    
    // „Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„ÅÑ„Éï„Ç°„Ç§„É´„Çí„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥
    logFiles.forEach(logFile => {
      if (logFile.size > maxLogSize) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const rotatedName = `${logFile.name.replace('.log', '')}-${timestamp}.log`;
        const rotatedPath = path.join(logsDir, rotatedName);
        
        fs.renameSync(logFile.path, rotatedPath);
        logInfo(`Rotated large log file: ${logFile.name} -> ${rotatedName}`);
        rotated++;
      }
    });
    
    // Âè§„ÅÑ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§
    const allLogFiles = fs.readdirSync(logsDir)
      .filter(file => file.endsWith('.log'))
      .map(file => {
        const fullPath = path.join(logsDir, file);
        const stats = fs.statSync(fullPath);
        return { name: file, path: fullPath, mtime: stats.mtime };
      })
      .sort((a, b) => b.mtime - a.mtime);
    
    if (allLogFiles.length > maxLogFiles) {
      const filesToDelete = allLogFiles.slice(maxLogFiles);
      filesToDelete.forEach(file => {
        fs.unlinkSync(file.path);
        logInfo(`Deleted old log file: ${file.name}`);
        rotated++;
      });
    }
    
    if (rotated === 0) {
      logInfo('No log rotation needed');
    } else {
      logSuccess(`Log rotation completed: ${rotated} files processed`);
    }
    
  } catch (error) {
    logWarning(`Log rotation failed: ${error.message}`);
  }
}

// „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
function clearSystemCache() {
  try {
    logInfo('Clearing system cache...');
    
    const cacheDirectories = [
      path.join(process.cwd(), 'node_modules', '.cache'),
      path.join(process.cwd(), 'dist'),
      path.join(process.cwd(), 'coverage'),
      path.join(process.cwd(), 'data', 'temp'),
      path.join(process.cwd(), 'data', 'cache')
    ];
    
    let cleared = 0;
    
    cacheDirectories.forEach(cacheDir => {
      if (fs.existsSync(cacheDir)) {
        try {
          const files = fs.readdirSync(cacheDir);
          files.forEach(file => {
            const filePath = path.join(cacheDir, file);
            const stats = fs.statSync(filePath);
            
            if (stats.isDirectory()) {
              fs.rmSync(filePath, { recursive: true, force: true });
            } else {
              fs.unlinkSync(filePath);
            }
          });
          
          logInfo(`Cleared cache directory: ${path.relative(process.cwd(), cacheDir)}`);
          cleared++;
        } catch (error) {
          logWarning(`Failed to clear ${cacheDir}: ${error.message}`);
        }
      }
    });
    
    // npm cache clean
    try {
      execSync('npm cache clean --force', { stdio: 'pipe' });
      logInfo('Cleared npm cache');
      cleared++;
    } catch (error) {
      logWarning(`Failed to clear npm cache: ${error.message}`);
    }
    
    if (cleared === 0) {
      logInfo('No cache to clear');
    } else {
      logSuccess(`Cache cleared: ${cleared} locations processed`);
    }
    
  } catch (error) {
    logWarning(`Cache clear failed: ${error.message}`);
  }
}

// Ë®≠ÂÆö„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
function backupConfiguration() {
  try {
    logInfo('Creating configuration backup...');
    
    const backupDir = path.join(process.cwd(), 'data', 'backups');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = `config-backup-${timestamp}`;
    const backupPath = path.join(backupDir, backupName);
    
    // „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    fs.mkdirSync(backupPath, { recursive: true });
    
    // „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂØæË±°„Éï„Ç°„Ç§„É´„Éª„Éá„Ç£„É¨„ÇØ„Éà„É™
    const backupTargets = [
      { src: 'config', dst: 'config' },
      { src: 'data/user-settings.json', dst: 'user-settings.json' },
      { src: 'package.json', dst: 'package.json' },
      { src: 'tsconfig.json', dst: 'tsconfig.json' },
      { src: '.eslintrc.js', dst: '.eslintrc.js' },
      { src: '.prettierrc', dst: '.prettierrc' }
    ];
    
    let backedUp = 0;
    
    backupTargets.forEach(target => {
      const srcPath = path.join(process.cwd(), target.src);
      const dstPath = path.join(backupPath, target.dst);
      
      if (fs.existsSync(srcPath)) {
        try {
          const stats = fs.statSync(srcPath);
          
          if (stats.isDirectory()) {
            fs.cpSync(srcPath, dstPath, { recursive: true });
          } else {
            fs.copyFileSync(srcPath, dstPath);
          }
          
          logInfo(`Backed up: ${target.src}`);
          backedUp++;
        } catch (error) {
          logWarning(`Failed to backup ${target.src}: ${error.message}`);
        }
      }
    });
    
    // „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„É°„Çø„Éá„Éº„Çø‰ΩúÊàê
    const metadata = {
      timestamp: new Date().toISOString(),
      nodeVersion: process.version,
      platform: os.platform(),
      backupName: backupName,
      filesCount: backedUp
    };
    
    fs.writeFileSync(
      path.join(backupPath, 'backup-metadata.json'),
      JSON.stringify(metadata, null, 2)
    );
    
    // Âè§„ÅÑ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅÆÂâäÈô§Ôºà10ÂÄã„Åæ„Åß‰øùÊåÅÔºâ
    const maxBackups = 10;
    const backupFiles = fs.readdirSync(backupDir)
      .filter(file => file.startsWith('config-backup-'))
      .map(file => {
        const fullPath = path.join(backupDir, file);
        const stats = fs.statSync(fullPath);
        return { name: file, path: fullPath, mtime: stats.mtime };
      })
      .sort((a, b) => b.mtime - a.mtime);
    
    if (backupFiles.length > maxBackups) {
      const filesToDelete = backupFiles.slice(maxBackups);
      filesToDelete.forEach(file => {
        fs.rmSync(file.path, { recursive: true, force: true });
        logInfo(`Deleted old backup: ${file.name}`);
      });
    }
    
    logSuccess(`Configuration backup created: ${backupName} (${backedUp} items)`);
    
  } catch (error) {
    logWarning(`Configuration backup failed: ${error.message}`);
  }
}

// „É°„Ç§„É≥Èñ¢Êï∞Ôºà„Ç™„Éó„Ç∑„Éß„É≥ÂØæÂøúÁâàÔºâ
async function main(options = {}) {
  logHeader('Renkei System Start');
  
  try {
    // „Ç™„Éó„Ç∑„Éß„É≥ÊÉÖÂ†±Ë°®Á§∫
    if (options.profile) {
      logInfo(`Using profile: ${options.profile}`);
    }
    if (options.restore) {
      logInfo(`Restoring session: ${options.restore}`);
    }
    if (options.debug) {
      logInfo('Debug mode enabled');
    }
    
    // 1. Ë®∫Êñ≠ÂÆüË°åÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
    if (options.diagnose) {
      const diagnostics = runDiagnostics();
      if (diagnostics.issues.length > 0) {
        logWarning('Issues detected during diagnostics. Continue? (Ctrl+C to abort)');
        // 3ÁßíÂæÖÊ©ü
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }
    
    // 2. Áí∞Â¢É„ÉÅ„Çß„ÉÉ„ÇØ
    preflightCheck();
    
    // 3. „Çª„ÉÉ„Ç∑„Éß„É≥Âæ©ÂÖÉÂá¶ÁêÜ
    let restoredSession = null;
    if (options.restore) {
      restoredSession = restoreSession(options.restore);
    }
    
    // 4. Ë®≠ÂÆöË™≠„ÅøËæº„Åø
    logHeader('Loading Configuration');
    const config = loadConfig(options.profile);
    
    // Âæ©ÂÖÉ„Åï„Çå„Åü„Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±„Çí„Éû„Éº„Ç∏
    if (restoredSession) {
      config.tmux.sessionName = restoredSession.sessionName;
      config.workspaceDir = restoredSession.workspaceDir;
      logInfo('Configuration merged with restored session data');
    }
    
    // 5. TypeScript„Éì„É´„Éâ
    logHeader('Building Application');
    buildTypeScript();
    
    // 6. tmux„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê
    logHeader('Setting up tmux Session');
    const sessionInfo = createTmuxSession(config);
    
    // 7. „Ç∑„Çπ„ÉÜ„É†Ëµ∑Âãï
    logHeader('Starting System');
    startSystem(config, sessionInfo);
    
    // 8. ÂàùÊúüÁîªÈù¢Ë°®Á§∫
    logHeader('Displaying Welcome Screen');
    displayWelcomeScreen(config, sessionInfo);
    
    // 9. „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã‰øùÂ≠ò
    saveSessionState(config);
    
    // 10. Ëµ∑ÂãïÂÆå‰∫Ü
    logHeader('Startup Complete');
    logSuccess('Renkei System has been started successfully!');
    
    // Ë®≠ÂÆöÊÉÖÂ†±Ë°®Á§∫
    if (config.currentProfile) {
      logInfo(`Active profile: ${config.currentProfile}`);
    }
    if (restoredSession) {
      logInfo(`Restored from session: ${restoredSession.timestamp}`);
    }
    
    logInfo('');
    logInfo('To attach to the tmux session, run:');
    logInfo(`  tmux attach-session -t ${config.tmux.sessionName}`);
    logInfo('');
    logInfo('To stop the system, run:');
    logInfo('  scripts/renkei-stop');
    logInfo('');
    logInfo('Session logs are available in: data/sessions/');
    
    // tmux„Çª„ÉÉ„Ç∑„Éß„É≥„Å´„Ç¢„Çø„ÉÉ„ÉÅÔºà--no-attach„Ç™„Éó„Ç∑„Éß„É≥„Åß„Å™„ÅÑÂ†¥ÂêàÔºâ
    if (!options.noAttach) {
      logInfo('Attaching to tmux session...');
      
      // Êó¢Â≠ò„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÂ†¥Âêà„ÅØ„Åô„Åê„Å´„Ç¢„Çø„ÉÉ„ÉÅ
      if (sessionInfo && sessionInfo.isExisting) {
        try {
          execSync(`tmux attach-session -t ${sessionInfo.sessionName}`, { stdio: 'inherit' });
        } catch (error) {
          logWarning(`Failed to attach to session: ${error.message}`);
          logInfo('You can manually attach with:');
          logInfo(`  tmux attach-session -t ${sessionInfo.sessionName}`);
        }
      } else {
        // Êñ∞Ë¶è„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÂ†¥Âêà„ÅØÂ∞ë„ÅóÂæÖÊ©ü
        setTimeout(() => {
          try {
            execSync(`tmux attach-session -t ${config.tmux.sessionName}`, { stdio: 'inherit' });
          } catch (error) {
            logWarning(`Failed to attach to session: ${error.message}`);
            logInfo('You can manually attach with:');
            logInfo(`  tmux attach-session -t ${config.tmux.sessionName}`);
          }
        }, 1000);
      }
    } else {
      logInfo('Skipping tmux attach (--no-attach specified)');
    }
    
  } catch (error) {
    logError(`Startup failed: ${error.message}`);
    logInfo('Please check the error above and try again.');
    logInfo('If setup is incomplete, run "scripts/renkei-setup" first.');
    process.exit(1);
  }
}

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞Âá¶ÁêÜ
function parseArguments() {
  const args = process.argv.slice(2);
  const options = {
    help: false,
    debug: false,
    noAttach: false,
    profile: null,
    restore: null,
    diagnose: false
  };
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case '--help':
      case '-h':
        options.help = true;
        break;
      case '--debug':
      case '-d':
        options.debug = true;
        break;
      case '--no-attach':
        options.noAttach = true;
        break;
      case '--profile':
      case '-p':
        if (i + 1 < args.length) {
          options.profile = args[++i];
        } else {
          logError('--profile requires a profile name');
          process.exit(1);
        }
        break;
      case '--restore':
      case '-r':
        if (i + 1 < args.length) {
          options.restore = args[++i];
        } else {
          logError('--restore requires a session ID or "latest"');
          process.exit(1);
        }
        break;
      case '--diagnose':
        options.diagnose = true;
        break;
      default:
        logWarning(`Unknown option: ${arg}`);
    }
  }
  
  return options;
}

// „Éò„É´„ÉóË°®Á§∫
function showHelp() {
  logHeader('Renkei Start - Help');
  logInfo('');
  logInfo('Usage: scripts/renkei-start [options]');
  logInfo('');
  logInfo('Basic Options:');
  logInfo('  -h, --help           Show this help message');
  logInfo('  -d, --debug          Enable debug mode with verbose logging');
  logInfo('  --no-attach          Start without attaching to tmux session');
  logInfo('');
  logInfo('Advanced Options:');
  logInfo('  -p, --profile NAME   Use specific configuration profile');
  logInfo('  -r, --restore ID     Restore from previous session (ID or "latest")');
  logInfo('  --diagnose           Run system diagnostics before starting');
  logInfo('');
  logInfo('Configuration Profiles:');
  logInfo('  Available profiles are stored in config/profiles/');
  logInfo('  Use --profile to specify: development, production, testing, etc.');
  logInfo('');
  logInfo('Session Restoration:');
  logInfo('  Use --restore latest          # Restore most recent session');
  logInfo('  Use --restore session-id     # Restore specific session');
  logInfo('  Session files are in data/sessions/');
  logInfo('');
  logInfo('Examples:');
  logInfo('  scripts/renkei-start                    # Normal startup');
  logInfo('  scripts/renkei-start --debug            # Debug mode');
  logInfo('  scripts/renkei-start --no-attach        # Background start');
  logInfo('  scripts/renkei-start -p development     # Use development profile');
  logInfo('  scripts/renkei-start -r latest          # Restore latest session');
  logInfo('  scripts/renkei-start --diagnose         # Run diagnostics first');
}

// „Çπ„ÇØ„É™„Éó„ÉàÂÆüË°å
if (require.main === module) {
  const options = parseArguments();
  
  if (options.help) {
    showHelp();
    process.exit(0);
  }
  
  if (options.debug) {
    logInfo('Debug mode enabled');
    process.env.RENKEI_DEBUG = 'true';
  }
  
  // „Éó„É≠„Éï„Ç°„Ç§„É´Â≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ
  if (options.profile) {
    const profiles = listAvailableProfiles();
    if (profiles.length === 0) {
      logWarning('No profiles directory found. Creating config/profiles/');
      try {
        const profilesDir = path.join(process.cwd(), 'config', 'profiles');
        fs.mkdirSync(profilesDir, { recursive: true });
        logInfo('Profiles directory created. Add profile files (.json) to use --profile option.');
      } catch (error) {
        logError(`Failed to create profiles directory: ${error.message}`);
      }
    } else if (!profiles.includes(options.profile)) {
      logError(`Profile '${options.profile}' not found.`);
      logInfo('Available profiles:');
      profiles.forEach(profile => logInfo(`  - ${profile}`));
      process.exit(1);
    }
  }
  
  main(options).catch(error => {
    logError(`Unexpected error: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { main, loadConfig };
