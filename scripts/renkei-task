#!/usr/bin/env node

/**
 * Renkei System - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * çµ±æ‹¬AIã«ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã™ã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«
 */

const { RenkeiSystem } = require('../dist/index.js');

// Chalk v5ã¯ESMãªã®ã§ã€CommonJSã§ç°¡æ˜“çš„ã«è‰²ä»˜ã‘ã‚’å®Ÿè£…
const chalk = {
  blue: (text) => `\x1b[34m${text}\x1b[0m`,
  green: (text) => `\x1b[32m${text}\x1b[0m`,
  yellow: (text) => `\x1b[33m${text}\x1b[0m`,
  red: (text) => `\x1b[31m${text}\x1b[0m`,
  gray: (text) => `\x1b[90m${text}\x1b[0m`
};

// Bold versions
chalk.blue.bold = (text) => `\x1b[1m\x1b[34m${text}\x1b[0m`;
chalk.green.bold = (text) => `\x1b[1m\x1b[32m${text}\x1b[0m`;
chalk.red.bold = (text) => `\x1b[1m\x1b[31m${text}\x1b[0m`;

// ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ
function parseArguments() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    showHelp();
    process.exit(1);
  }

  const command = args[0];
  const taskDescription = args.slice(1).join(' ');

  return { command, taskDescription };
}

// ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
function showHelp() {
  console.log(chalk.blue.bold('ğŸ¤– Renkei Task - AIæŒ‡ç¤ºãƒ„ãƒ¼ãƒ«'));
  console.log('');
  console.log('ä½¿ç”¨æ–¹æ³•:');
  console.log('  scripts/renkei-task <æŒ‡ç¤ºå†…å®¹>');
  console.log('');
  console.log('ä¾‹:');
  console.log('  scripts/renkei-task "READMEãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦"');
  console.log('  scripts/renkei-task "package.jsonã‚’ç¢ºèªã—ã¦ãã ã•ã„"');
  console.log('  scripts/renkei-task "ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ãã ã•ã„"');
  console.log('');
  console.log('ç‰¹åˆ¥ãªã‚³ãƒãƒ³ãƒ‰:');
  console.log('  scripts/renkei-task status    - ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’è¡¨ç¤º');
  console.log('  scripts/renkei-task help      - ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º');
}

// å®Ÿéš›ã®Claude AIçµ±åˆã‚¿ã‚¹ã‚¯å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ 
async function executeTask(taskDescription) {
  try {
    console.log(chalk.blue.bold('ğŸ¤– Renkei System - çµ±æ‹¬AI ã§ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™...'));
    console.log('');
    console.log(chalk.blue('ğŸ“ å—ã‘ä»˜ã‘ãŸã‚¿ã‚¹ã‚¯:'));
    console.log(chalk.gray(`   ${taskDescription}`));
    console.log('');

    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åé›†
    console.log(chalk.blue('ğŸ” ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åé›†ã—ã¦ã„ã¾ã™...'));
    const { claudeAPI, projectContextCollector } = require('../dist/integrations/claude-api.js');
    
    const projectContext = await projectContextCollector.collectContext();
    console.log(chalk.gray(`   ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${projectContext.projectName} (${projectContext.language})`));
    console.log(chalk.gray(`   ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: ${projectContext.frameworks.join(', ') || 'ãªã—'}`));

    // Claude AIã§ã‚¿ã‚¹ã‚¯è§£æãƒ»å®Ÿè¡Œè¨ˆç”»
    console.log(chalk.blue('ğŸ§  Claude AI ãŒã‚¿ã‚¹ã‚¯ã‚’è§£æã—ã¦ã„ã¾ã™...'));
    
    const claudeResponse = await claudeAPI.executeTaskWithContext(taskDescription, projectContext);
    
    console.log(chalk.green.bold('\nâœ… Claude AI ã«ã‚ˆã‚‹è§£æãŒå®Œäº†ã—ã¾ã—ãŸï¼'));
    console.log('');
    console.log(chalk.blue('ğŸ”§ å®Ÿè¡Œè¨ˆç”»:'));
    console.log(chalk.gray(claudeResponse.content));
    
    // å®Ÿéš›ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®è©¦è¡Œ
    console.log('');
    console.log(chalk.blue('âš¡ å®Ÿè¡Œå¯èƒ½ãªéƒ¨åˆ†ã‚’å‡¦ç†ã—ã¦ã„ã¾ã™...'));
    const executionResult = await tryExecuteClaudeInstructions(claudeResponse.content);
    
    console.log('');
    console.log(chalk.green.bold('ğŸ‰ ã‚¿ã‚¹ã‚¯å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼'));
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨é‡è¡¨ç¤º
    if (claudeResponse.usage) {
      console.log('');
      console.log(chalk.gray(`ğŸ“Š AIä½¿ç”¨é‡: å…¥åŠ›${claudeResponse.usage.input_tokens}ã€å‡ºåŠ›${claudeResponse.usage.output_tokens}ãƒˆãƒ¼ã‚¯ãƒ³`));
    }
    
    return `Claude AIè§£æå®Œäº†\nå®Ÿè¡Œçµæœ: ${executionResult}`;
    
  } catch (error) {
    // Claude API ãŒåˆ©ç”¨ã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (error.message.includes('Claude API key is not configured')) {
      console.log(chalk.yellow('âš ï¸  Claude APIæœªè¨­å®šã€‚ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹å‡¦ç†ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™...'));
      return await analyzeAndExecuteTask(taskDescription);
    }
    
    console.error(chalk.red.bold('âŒ AIçµ±åˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:'), error.message);
    throw error;
  }
}

// Claude AIã®æŒ‡ç¤ºã‚’å®Ÿéš›ã«å®Ÿè¡Œã™ã‚‹è©¦è¡Œ
async function tryExecuteClaudeInstructions(claudeInstructions) {
  try {
    // Claude ã®å›ç­”ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡ºã—ã¦å®Ÿè¡Œ
    const fs = require('fs');
    const { execSync } = require('child_process');
    
    const results = [];
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã®æŒ‡ç¤ºã‚’æ¤œå‡º
    const fileCreationRegex = /ãƒ•ã‚¡ã‚¤ãƒ«[^\n]*ä½œæˆ[^\n]*[:ï¼š]\s*([^\n]+)/gi;
    const fileMatches = claudeInstructions.match(fileCreationRegex);
    if (fileMatches) {
      results.push('ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæŒ‡ç¤ºã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
    }
    
    // ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã®æŒ‡ç¤ºã‚’æ¤œå‡º
    const commandRegex = /```(?:bash|sh|shell|cmd)\n([^`]+)\n```/gi;
    let commandMatch;
    while ((commandMatch = commandRegex.exec(claudeInstructions)) !== null) {
      const command = commandMatch[1].trim();
      try {
        console.log(chalk.blue(`  ğŸ”§ å®Ÿè¡Œ: ${command}`));
        const output = execSync(command, { encoding: 'utf8', timeout: 10000 });
        results.push(`ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡ŒæˆåŠŸ: ${command}`);
      } catch (error) {
        results.push(`ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå¤±æ•—: ${command} (${error.message})`);
      }
    }
    
    // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®æ¤œå‡ºï¼ˆTypeScript/JavaScriptï¼‰
    const codeRegex = /```(?:typescript|ts|javascript|js)\n([^`]+)\n```/gi;
    let codeMatch;
    while ((codeMatch = codeRegex.exec(claudeInstructions)) !== null) {
      results.push('ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
    }
    
    if (results.length === 0) {
      return 'Claude AIã«ã‚ˆã‚‹è©³ç´°ãªè§£æã¨æŒ‡ç¤ºã‚’æä¾›ã—ã¾ã—ãŸ';
    }
    
    return results.join(', ');
    
  } catch (error) {
    return `å®Ÿè¡Œå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: ${error.message}`;
  }
}

// ã‚¿ã‚¹ã‚¯è§£æãƒ»å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
async function analyzeAndExecuteTask(description) {
  const fs = require('fs');
  const path = require('path');
  const { execSync } = require('child_process');
  
  // ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã‚’è§£æ
  const lowerDesc = description.toLowerCase();
  
  try {
    // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã‚¿ã‚¹ã‚¯
    if (lowerDesc.includes('readme') || lowerDesc.includes('ãƒ•ã‚¡ã‚¤ãƒ«') && lowerDesc.includes('ä½œæˆ')) {
      if (lowerDesc.includes('readme')) {
        return await createReadmeFile();
      } else {
        return await createGenericFile(description);
      }
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèªã‚¿ã‚¹ã‚¯
    else if (lowerDesc.includes('ç¢ºèª') || lowerDesc.includes('ãƒã‚§ãƒƒã‚¯') || lowerDesc.includes('è¦‹ã‚‹')) {
      if (lowerDesc.includes('package.json')) {
        return await checkPackageJson();
      } else {
        return await listProjectFiles();
      }
    }
    
    // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¿ã‚¹ã‚¯
    else if (lowerDesc.includes('ãƒ†ã‚¹ãƒˆ') || lowerDesc.includes('test')) {
      return await runTests();
    }
    
    // ãƒ“ãƒ«ãƒ‰ã‚¿ã‚¹ã‚¯
    else if (lowerDesc.includes('ãƒ“ãƒ«ãƒ‰') || lowerDesc.includes('build')) {
      return await buildProject();
    }
    
    // GitçŠ¶æ…‹ç¢ºèª
    else if (lowerDesc.includes('git') || lowerDesc.includes('çŠ¶æ…‹')) {
      return await checkGitStatus();
    }
    
    // ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
    else if (lowerDesc.includes('ã‚·ã‚¹ãƒ†ãƒ ') || lowerDesc.includes('æƒ…å ±')) {
      return await getSystemInfo();
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: æ±ç”¨çš„ãªå¿œç­”
    else {
      return await handleGenericTask(description);
    }
    
  } catch (error) {
    return `ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
  }
}

// å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–¢æ•°ç¾¤
async function createReadmeFile() {
  const fs = require('fs');
  
  const readmeContent = `# Renkei System

AIå”èª¿é–‹ç™ºç’°å¢ƒ - tmuxãƒ™ãƒ¼ã‚¹ã®çµ±æ‹¬AIãƒ»workerã‚·ã‚¹ãƒ†ãƒ 

## æ¦‚è¦
Renkeiã¯AIã‚’æ´»ç”¨ã—ãŸé–‹ç™ºæ”¯æ´ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚çµ±æ‹¬AIã¨workerãƒ—ãƒ­ã‚»ã‚¹ãŒå”èª¿ã—ã¦ã€é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’åŠ¹ç‡çš„ã«å‡¦ç†ã—ã¾ã™ã€‚

## ä½¿ç”¨æ–¹æ³•

### ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•
\`\`\`bash
./scripts/renkei-start
\`\`\`

### ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
\`\`\`bash
./scripts/renkei-task "æŒ‡ç¤ºå†…å®¹"
\`\`\`

### ã‚·ã‚¹ãƒ†ãƒ åœæ­¢
\`\`\`bash
./scripts/renkei-stop
\`\`\`

## ç‰¹å¾´
- tmuxãƒ™ãƒ¼ã‚¹ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
- çµ±æ‹¬AIãƒ»workerãƒ—ãƒ­ã‚»ã‚¹ç®¡ç†
- ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ãƒ»å¾©å…ƒæ©Ÿèƒ½
- ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³çµ±åˆ

Generated by Renkei AI System - ${new Date().toISOString()}
`;

  try {
    fs.writeFileSync('README-generated.md', readmeContent);
    return 'README-generated.md ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦ã¨ä½¿ç”¨æ–¹æ³•ã‚’è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚';
  } catch (error) {
    throw new Error(`READMEä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
  }
}

async function checkPackageJson() {
  const fs = require('fs');
  
  try {
    if (!fs.existsSync('package.json')) {
      return 'package.json ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚';
    }
    
    const packageData = JSON.parse(fs.readFileSync('package.json', 'utf8'));
    
    const analysis = [
      `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå: ${packageData.name}`,
      `ãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${packageData.version}`,
      `èª¬æ˜: ${packageData.description || 'æœªè¨­å®š'}`,
      `ä¾å­˜é–¢ä¿‚æ•°: ${Object.keys(packageData.dependencies || {}).length}å€‹`,
      `é–‹ç™ºä¾å­˜é–¢ä¿‚æ•°: ${Object.keys(packageData.devDependencies || {}).length}å€‹`,
      `ä¸»è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆ: ${Object.keys(packageData.scripts || {}).join(', ')}`
    ];
    
    return analysis.join('\n   ');
  } catch (error) {
    throw new Error(`package.json è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
  }
}

async function listProjectFiles() {
  const fs = require('fs');
  const path = require('path');
  
  try {
    const files = fs.readdirSync('.').filter(file => {
      return !file.startsWith('.') && !['node_modules', 'dist', 'coverage'].includes(file);
    });
    
    const dirs = files.filter(file => fs.statSync(file).isDirectory());
    const regularFiles = files.filter(file => fs.statSync(file).isFile());
    
    const result = [
      `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ :`,
      `ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (${dirs.length}å€‹): ${dirs.join(', ')}`,
      `ãƒ•ã‚¡ã‚¤ãƒ« (${regularFiles.length}å€‹): ${regularFiles.slice(0, 10).join(', ')}${regularFiles.length > 10 ? '...' : ''}`
    ];
    
    return result.join('\n   ');
  } catch (error) {
    throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
  }
}

async function runTests() {
  const { execSync } = require('child_process');
  
  try {
    const output = execSync('npm test', { encoding: 'utf8', timeout: 10000 });
    return `ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå®Œäº†:\n   ${output.split('\n').slice(-5).join('\n   ')}`;
  } catch (error) {
    return `ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœ: ${error.message.includes('No tests found') ? 'ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : 'ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'}`;
  }
}

async function buildProject() {
  const { execSync } = require('child_process');
  
  try {
    const output = execSync('npm run build', { encoding: 'utf8', timeout: 30000 });
    return 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ“ãƒ«ãƒ‰ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸã€‚';
  } catch (error) {
    throw new Error(`ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`);
  }
}

async function checkGitStatus() {
  const { execSync } = require('child_process');
  
  try {
    const status = execSync('git status --porcelain', { encoding: 'utf8' });
    const branch = execSync('git branch --show-current', { encoding: 'utf8' }).trim();
    
    if (status.trim() === '') {
      return `GitçŠ¶æ…‹: ãƒ–ãƒ©ãƒ³ãƒ '${branch}' - å¤‰æ›´ãªã—ï¼ˆã‚¯ãƒªãƒ¼ãƒ³ï¼‰`;
    } else {
      const changes = status.split('\n').filter(line => line.trim()).length;
      return `GitçŠ¶æ…‹: ãƒ–ãƒ©ãƒ³ãƒ '${branch}' - ${changes}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›´ãŒã‚ã‚Šã¾ã™`;
    }
  } catch (error) {
    return 'Gitãƒªãƒã‚¸ãƒˆãƒªã§ã¯ãªã„ã‹ã€Gitã‚³ãƒãƒ³ãƒ‰ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
  }
}

async function getSystemInfo() {
  const os = require('os');
  const { execSync } = require('child_process');
  
  try {
    const nodeVersion = process.version;
    const platform = os.platform();
    const arch = os.arch();
    const memory = Math.round(os.totalmem() / 1024 / 1024 / 1024);
    
    let tmuxVersion = 'æœªæ¤œå‡º';
    try {
      tmuxVersion = execSync('tmux -V', { encoding: 'utf8' }).trim();
    } catch {}
    
    const info = [
      `ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ : ${platform} (${arch})`,
      `Node.js: ${nodeVersion}`,
      `tmux: ${tmuxVersion}`,
      `ãƒ¡ãƒ¢ãƒª: ${memory}GB`,
      `Renkei System: å‹•ä½œä¸­`
    ];
    
    return info.join('\n   ');
  } catch (error) {
    throw new Error(`ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}`);
  }
}

async function createGenericFile(description) {
  return `ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã‚¿ã‚¹ã‚¯ã‚’è§£æã—ã¾ã—ãŸãŒã€å…·ä½“çš„ãªãƒ•ã‚¡ã‚¤ãƒ«åãŒä¸æ˜ã§ã™ã€‚'scripts/renkei-task "READMEä½œæˆ"' ã®ã‚ˆã†ã«ã‚ˆã‚Šå…·ä½“çš„ã«æŒ‡ç¤ºã—ã¦ãã ã•ã„ã€‚`;
}

async function handleGenericTask(description) {
  const suggestions = [
    '"READMEä½œæˆ" - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®READMEãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ',
    '"package.jsonç¢ºèª" - package.jsonã®å†…å®¹ã‚’è§£æ',
    '"ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª" - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¡¨ç¤º',
    '"ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ" - npmãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ',
    '"ãƒ“ãƒ«ãƒ‰å®Ÿè¡Œ" - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ“ãƒ«ãƒ‰',
    '"GitçŠ¶æ…‹ç¢ºèª" - Gitãƒªãƒã‚¸ãƒˆãƒªã®çŠ¶æ…‹ã‚’ç¢ºèª',
    '"ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±" - ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ã‚’è¡¨ç¤º'
  ];
  
  return `æŒ‡ç¤ºã‚’è§£æã—ã¾ã—ãŸãŒã€å…·ä½“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n\nåˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯ã®ä¾‹:\n   ${suggestions.join('\n   ')}\n\nã‚ˆã‚Šå…·ä½“çš„ãªæŒ‡ç¤ºã‚’ãŠè©¦ã—ãã ã•ã„ã€‚`;
}

// ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®è¡¨ç¤º
async function showStatus() {
  try {
    console.log(chalk.blue.bold('ğŸ“Š Renkei System çŠ¶æ…‹ç¢ºèª'));
    console.log('');
    
    // tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç¢ºèª
    const { execSync } = require('child_process');
    
    try {
      execSync('tmux has-session -t renkei', { stdio: 'pipe' });
      console.log(chalk.green('âœ… tmux session "renkei" - å®Ÿè¡Œä¸­'));
      
      // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã®å–å¾—
      const sessionInfo = execSync('tmux list-sessions -F "#{session_name}: #{session_windows} windows, created #{session_created}"', { encoding: 'utf8' });
      console.log(chalk.gray(`   ${sessionInfo.trim()}`));
      
    } catch (error) {
      console.log(chalk.red('âŒ tmux session "renkei" - åœæ­¢ä¸­'));
      console.log(chalk.yellow('ğŸ’¡ ã‚·ã‚¹ãƒ†ãƒ ã‚’èµ·å‹•ã™ã‚‹ã«ã¯: ./scripts/renkei-start'));
    }
    
    console.log('');
    console.log(chalk.blue('ğŸ“‹ åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰:'));
    console.log(chalk.gray('   scripts/renkei-task "<æŒ‡ç¤º>"  - ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ'));
    console.log(chalk.gray('   scripts/renkei-task status    - çŠ¶æ…‹ç¢ºèª'));
    console.log(chalk.gray('   scripts/renkei-task help      - ãƒ˜ãƒ«ãƒ—è¡¨ç¤º'));
    console.log(chalk.gray('   ./scripts/renkei-start        - ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•'));
    console.log(chalk.gray('   ./scripts/renkei-stop         - ã‚·ã‚¹ãƒ†ãƒ åœæ­¢'));
    
  } catch (error) {
    console.error(chalk.red.bold('âŒ çŠ¶æ…‹ç¢ºèªã‚¨ãƒ©ãƒ¼:'), error.message);
  }
}

// ãƒ¡ã‚¤ãƒ³å‡¦ç†
async function main() {
  const { command, taskDescription } = parseArguments();
  
  try {
    switch (command) {
      case 'help':
      case '--help':
      case '-h':
        showHelp();
        break;
        
      case 'status':
        await showStatus();
        break;
        
      default:
        // ã‚³ãƒãƒ³ãƒ‰ + æ®‹ã‚Šã®å¼•æ•°ã‚’ã‚¿ã‚¹ã‚¯è¨˜è¿°ã¨ã—ã¦æ‰±ã†
        const fullTaskDescription = [command, taskDescription].filter(Boolean).join(' ');
        await executeTask(fullTaskDescription);
        break;
    }
  } catch (error) {
    console.error(chalk.red.bold('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:'), error.message);
    process.exit(1);
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  main();
}
