#!/usr/bin/env node

/**
 * Renkei System - Stop Script
 * ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜ãƒ»ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// ã‚«ãƒ©ãƒ¼å‡ºåŠ›ç”¨ã®å®šæ•°
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

// ãƒ­ã‚°å‡ºåŠ›é–¢æ•°
function log(message, color = colors.white) {
  console.log(`${color}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`âœ… ${message}`, colors.green);
}

function logError(message) {
  log(`âŒ ${message}`, colors.red);
}

function logWarning(message) {
  log(`âš ï¸  ${message}`, colors.yellow);
}

function logInfo(message) {
  log(`â„¹ï¸  ${message}`, colors.blue);
}

function logHeader(message) {
  log(`\n${colors.bold}ðŸ›‘ ${message}${colors.reset}`, colors.cyan);
}

// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
function loadConfig() {
  const userSettingsPath = path.join(process.cwd(), 'data/user-settings.json');
  const defaultSettingsPath = path.join(process.cwd(), 'config/default-settings.json');
  
  let config;
  
  try {
    if (fs.existsSync(userSettingsPath)) {
      config = JSON.parse(fs.readFileSync(userSettingsPath, 'utf8'));
    } else if (fs.existsSync(defaultSettingsPath)) {
      config = JSON.parse(fs.readFileSync(defaultSettingsPath, 'utf8'));
    } else {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§æœ€ä½Žé™ã®åœæ­¢å‡¦ç†ã‚’å®Ÿè¡Œ
      config = {
        tmux: { sessionName: 'renkei-session' },
        sessionDir: path.join(process.cwd(), 'data/sessions')
      };
      logWarning('Configuration file not found. Using default settings for shutdown.');
    }
    
    return config;
  } catch (error) {
    logError(`Failed to load configuration: ${error.message}`);
    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã‚ãªãã¦ã‚‚ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã¯å®Ÿè¡Œ
    return {
      tmux: { sessionName: 'renkei-session' },
      sessionDir: path.join(process.cwd(), 'data/sessions')
    };
  }
}

// tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³å­˜åœ¨ãƒã‚§ãƒƒã‚¯
function checkTmuxSession(sessionName) {
  try {
    execSync(`tmux has-session -t ${sessionName}`, { stdio: 'pipe' });
    return true;
  } catch (error) {
    return false;
  }
}

// å®Ÿè¡Œä¸­ãƒ—ãƒ­ã‚»ã‚¹æ¤œç´¢
function findRenkeiProcesses() {
  try {
    const processes = [];
    
    // Node.jsãƒ—ãƒ­ã‚»ã‚¹ã‚’æ¤œç´¢
    try {
      const psOutput = execSync('ps aux', { encoding: 'utf8', stdio: 'pipe' });
      const lines = psOutput.split('\n');
      
      for (const line of lines) {
        if (line.includes('node') && (line.includes('dist/index.js') || line.includes('renkei'))) {
          const parts = line.trim().split(/\s+/);
          if (parts.length >= 2) {
            const pid = parseInt(parts[1]);
            if (!isNaN(pid)) {
              processes.push({ pid, command: parts.slice(10).join(' ') });
            }
          }
        }
        // tail -f ã‚³ãƒžãƒ³ãƒ‰ã‚‚å¯¾è±¡ã«å«ã‚ã‚‹
        if (line.includes('tail') && line.includes('renkei-worker.log')) {
          const parts = line.trim().split(/\s+/);
          if (parts.length >= 2) {
            const pid = parseInt(parts[1]);
            if (!isNaN(pid)) {
              processes.push({ pid, command: parts.slice(10).join(' ') });
            }
          }
        }
      }
    } catch (error) {
      logWarning('Failed to search for Node.js processes');
    }
    
    return processes;
  } catch (error) {
    logWarning(`Failed to find Renkei processes: ${error.message}`);
    return [];
  }
}

// ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¿å­˜
function saveSessionState(config, sessionData = {}) {
  try {
    logInfo('Saving session state...');
    
    const sessionDir = config.sessionDir || path.join(process.cwd(), 'data/sessions');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sessionStateFile = path.join(sessionDir, `shutdown-${timestamp}.json`);
    
    // tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±å–å¾—
    let tmuxInfo = null;
    if (checkTmuxSession(config.tmux.sessionName)) {
      try {
        const sessionInfo = execSync(`tmux display-message -t ${config.tmux.sessionName} -p "#{session_name},#{session_created},#{session_windows}"`, { encoding: 'utf8', stdio: 'pipe' });
        const [name, created, windows] = sessionInfo.trim().split(',');
        tmuxInfo = { name, created, windows: parseInt(windows) };
      } catch (error) {
        logWarning('Failed to get tmux session info');
      }
    }
    
    const sessionState = {
      timestamp: new Date().toISOString(),
      shutdownReason: sessionData.reason || 'manual',
      sessionName: config.tmux.sessionName,
      tmuxInfo,
      workspaceDir: config.workspaceDir,
      platform: os.platform(),
      nodeVersion: process.version,
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      ...sessionData
    };
    
    // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç¢ºèªãƒ»ä½œæˆ
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true });
    }
    
    fs.writeFileSync(sessionStateFile, JSON.stringify(sessionState, null, 2));
    logSuccess(`Session state saved: ${sessionStateFile}`);
    
    return sessionStateFile;
  } catch (error) {
    logWarning(`Failed to save session state: ${error.message}`);
    return null;
  }
}

// ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†
function terminateProcesses(config, force = false) {
  try {
    logInfo('Terminating Renkei processes...');
    
    const processes = findRenkeiProcesses();
    
    if (processes.length === 0) {
      logInfo('No Renkei processes found');
      return;
    }
    
    logInfo(`Found ${processes.length} Renkei process(es)`);
    
    for (const process of processes) {
      try {
        logInfo(`Terminating process ${process.pid}: ${process.command}`);
        
        if (force) {
          execSync(`kill -KILL ${process.pid}`, { stdio: 'pipe' });
          logSuccess(`Force killed process ${process.pid}`);
        } else {
          execSync(`kill -TERM ${process.pid}`, { stdio: 'pipe' });
          logSuccess(`Gracefully terminated process ${process.pid}`);
        }
      } catch (error) {
        logWarning(`Failed to terminate process ${process.pid}: ${error.message}`);
      }
    }
    
    // ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†å¾…æ©Ÿ
    if (!force) {
      logInfo('Waiting for processes to exit gracefully...');
      setTimeout(() => {
        const remainingProcesses = findRenkeiProcesses();
        if (remainingProcesses.length > 0) {
          logWarning(`${remainingProcesses.length} process(es) still running. Use --force to kill them.`);
        }
      }, 2000);
    }
    
  } catch (error) {
    logError(`Failed to terminate processes: ${error.message}`);
  }
}

// tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤
function deleteTmuxSession(config, backup = true) {
  try {
    const sessionName = config.tmux.sessionName;
    
    if (!checkTmuxSession(sessionName)) {
      logInfo(`tmux session '${sessionName}' does not exist`);
      return;
    }
    
    logInfo(`Deleting tmux session: ${sessionName}`);
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    if (backup) {
      try {
        const sessionInfo = execSync(`tmux list-sessions -F "#{session_name}: #{session_windows} windows, created #{session_created_string}"`, { encoding: 'utf8', stdio: 'pipe' });
        logInfo(`Session info: ${sessionInfo.trim()}`);
      } catch (error) {
        logWarning('Failed to get session info for backup');
      }
    }
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤
    execSync(`tmux kill-session -t ${sessionName}`, { stdio: 'pipe' });
    logSuccess(`tmux session '${sessionName}' deleted`);
    
  } catch (error) {
    logError(`Failed to delete tmux session: ${error.message}`);
  }
}

// ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
function rotateLogFiles(config) {
  try {
    const logDir = path.join(process.cwd(), 'data/logs');
    
    if (!fs.existsSync(logDir)) {
      return;
    }
    
    logInfo('Rotating log files...');
    
    const logFiles = fs.readdirSync(logDir).filter(file => file.endsWith('.log'));
    const maxLogFiles = 10; // æœ€å¤§ä¿æŒãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«æ•°
    
    if (logFiles.length > maxLogFiles) {
      // å¤ã„ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
      const sortedFiles = logFiles
        .map(file => ({
          name: file,
          path: path.join(logDir, file),
          mtime: fs.statSync(path.join(logDir, file)).mtime
        }))
        .sort((a, b) => a.mtime - b.mtime);
      
      const filesToDelete = sortedFiles.slice(0, sortedFiles.length - maxLogFiles);
      
      for (const file of filesToDelete) {
        fs.unlinkSync(file.path);
        logInfo(`Deleted old log file: ${file.name}`);
      }
    }
    
    logSuccess('Log file rotation completed');
    
  } catch (error) {
    logWarning(`Failed to rotate log files: ${error.message}`);
  }
}

// ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
function cleanupTempFiles(config) {
  try {
    const tempDir = path.join(config.workspaceDir || process.cwd(), 'temp');
    
    if (!fs.existsSync(tempDir)) {
      return;
    }
    
    logInfo('Cleaning up temporary files...');
    
    const tempFiles = fs.readdirSync(tempDir);
    let deletedCount = 0;
    
    for (const file of tempFiles) {
      if (file === '.gitkeep') {
        continue; // .gitkeepã¯ä¿æŒ
      }
      
      try {
        const filePath = path.join(tempDir, file);
        const stats = fs.statSync(filePath);
        
        if (stats.isFile()) {
          fs.unlinkSync(filePath);
          deletedCount++;
        } else if (stats.isDirectory()) {
          fs.rmSync(filePath, { recursive: true, force: true });
          deletedCount++;
        }
      } catch (error) {
        logWarning(`Failed to delete temp file ${file}: ${error.message}`);
      }
    }
    
    if (deletedCount > 0) {
      logSuccess(`Cleaned up ${deletedCount} temporary file(s)`);
    } else {
      logInfo('No temporary files to clean up');
    }
    
  } catch (error) {
    logWarning(`Failed to cleanup temp files: ${error.message}`);
  }
}

// ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
function checkSystemStatus(config) {
  logHeader('System Status Check');
  
  const status = {
    tmuxSession: false,
    renkeiProcesses: 0,
    configLoaded: false
  };
  
  // tmux ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
  if (checkTmuxSession(config.tmux.sessionName)) {
    status.tmuxSession = true;
    logInfo(`âœ… tmux session '${config.tmux.sessionName}' is running`);
  } else {
    logInfo(`âŒ tmux session '${config.tmux.sessionName}' not found`);
  }
  
  // ãƒ—ãƒ­ã‚»ã‚¹ãƒã‚§ãƒƒã‚¯
  const processes = findRenkeiProcesses();
  status.renkeiProcesses = processes.length;
  if (processes.length > 0) {
    logInfo(`âœ… Found ${processes.length} Renkei process(es)`);
    processes.forEach(proc => {
      logInfo(`   PID ${proc.pid}: ${proc.command}`);
    });
  } else {
    logInfo(`âŒ No Renkei processes found`);
  }
  
  // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯
  const configPath = path.join(process.cwd(), 'data/user-settings.json');
  if (fs.existsSync(configPath)) {
    status.configLoaded = true;
    logInfo(`âœ… Configuration file found: ${configPath}`);
  } else {
    logInfo(`âŒ Configuration file not found: ${configPath}`);
  }
  
  return status;
}

// ãƒ¡ã‚¤ãƒ³é–¢æ•°
async function main() {
  logHeader('Renkei System Stop');
  
  try {
    // 1. è¨­å®šèª­ã¿è¾¼ã¿
    logHeader('Loading Configuration');
    const config = loadConfig();
    
    // 2. ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯
    const status = checkSystemStatus(config);
    
    if (!status.tmuxSession && status.renkeiProcesses === 0) {
      logInfo('Renkei System is not currently running');
      logInfo('Performing cleanup operations...');
    }
    
    // 3. ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ä¿å­˜
    logHeader('Saving Session State');
    const sessionData = {
      reason: 'manual_shutdown',
      systemStatus: status
    };
    saveSessionState(config, sessionData);
    
    // 4. ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†
    logHeader('Terminating Processes');
    const options = parseArguments();
    terminateProcesses(config, options.force);
    
    // 5. tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤
    logHeader('Cleaning up tmux Session');
    deleteTmuxSession(config, !options.noBackup);
    
    // 6. ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    logHeader('Log Maintenance');
    rotateLogFiles(config);
    
    // 7. ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    logHeader('Cleanup Temporary Files');
    cleanupTempFiles(config);
    
    // 8. åœæ­¢å®Œäº†
    logHeader('Shutdown Complete');
    logSuccess('Renkei System has been stopped successfully!');
    logInfo('');
    logInfo('Session data has been saved to: data/sessions/');
    logInfo('To restart the system, run: scripts/renkei-start');
    
  } catch (error) {
    logError(`Shutdown failed: ${error.message}`);
    logInfo('Some cleanup operations may have failed.');
    logInfo('You may need to manually kill remaining processes or tmux sessions.');
    process.exit(1);
  }
}

// ã‚³ãƒžãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°å‡¦ç†
function parseArguments() {
  const args = process.argv.slice(2);
  const options = {
    help: false,
    force: false,
    noBackup: false,
    statusOnly: false
  };
  
  for (const arg of args) {
    switch (arg) {
      case '--help':
      case '-h':
        options.help = true;
        break;
      case '--force':
      case '-f':
        options.force = true;
        break;
      case '--no-backup':
        options.noBackup = true;
        break;
      case '--status':
      case '-s':
        options.statusOnly = true;
        break;
      default:
        logWarning(`Unknown option: ${arg}`);
    }
  }
  
  return options;
}

// ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
function showHelp() {
  logHeader('Renkei Stop - Help');
  logInfo('');
  logInfo('Usage: scripts/renkei-stop [options]');
  logInfo('');
  logInfo('Options:');
  logInfo('  -h, --help        Show this help message');
  logInfo('  -f, --force       Force kill processes (SIGKILL)');
  logInfo('  --no-backup       Skip session backup');
  logInfo('  -s, --status      Show status only (no shutdown)');
  logInfo('');
  logInfo('Examples:');
  logInfo('  scripts/renkei-stop           # Normal shutdown');
  logInfo('  scripts/renkei-stop --force   # Force shutdown');
  logInfo('  scripts/renkei-stop --status  # Check status only');
}

// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã®ã¿
function statusOnly() {
  logHeader('Renkei System Status');
  
  try {
    const config = loadConfig();
    const status = checkSystemStatus(config);
    
    logInfo('');
    if (status.tmuxSession || status.renkeiProcesses > 0) {
      logInfo('ðŸŸ¢ Renkei System is RUNNING');
    } else {
      logInfo('ðŸ”´ Renkei System is STOPPED');
    }
    
    logInfo('');
    logInfo('To stop the system, run: scripts/renkei-stop');
    
  } catch (error) {
    logError(`Status check failed: ${error.message}`);
    process.exit(1);
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  const options = parseArguments();
  
  if (options.help) {
    showHelp();
    process.exit(0);
  }
  
  if (options.statusOnly) {
    statusOnly();
    process.exit(0);
  }
  
  if (options.force) {
    logWarning('Force shutdown mode enabled');
  }
  
  main().catch(error => {
    logError(`Unexpected error: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { main, loadConfig, checkSystemStatus };
